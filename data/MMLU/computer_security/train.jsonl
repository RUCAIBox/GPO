{"input": "The four Primary Security Principles related to messages are\n(A) Confidentiality, Integrity, Non repudiation and Authentication\n(B) Confidentiality, Access Control, Integrity, Non repudiation\n(C) Authentication, Authorization, Availability, Integrity\n(D) Availability, Authorization, Confidentiality, Integrity", "output": "(A)"}
{"input": "What is a replay attack?\n(A) When the attacker replies to a message sent to it by the system\n(B) An attack that continuously repeats, probing for a weakness\n(C) An attack that uses the system's own messages and so cannot be defended against\n(D) The attacker resends a captured message, and the site accept its and responds in the attacker's favor", "output": "(D)"}
{"input": "____________ is also a part of darknet that is employed for transferring files anonymously.\n(A) Freenet\n(B) ARPANET\n(C) Stuxnet\n(D) Internet", "output": "(A)"}
{"input": "A __________ is a sequential segment of the memory location that is allocated for containing some data such as a character string or an array of integers.\n(A) stack\n(B) queue\n(C) external storage\n(D) buffer", "output": "(D)"}
{"input": "Suppose you want to use fuzzing on a program to try to find memory errors; which of the following statements is true?\n(A) You should not use a grammar-based fuzzer, because its adherence to the grammar means it will not find memory errors\n(B) Compiling the program with address sanitizer (ASAN) will make errors harder to reproduce\n(C) Compiling the program with address sanitizer (ASAN) will make the source of a memory error easier to find\n(D) Fuzzing doesn't find memory errors, it finds crashes and hangs", "output": "(C)"}
{"input": "Which of the following is a remote Trojan?\n(A) Troya\n(B) DaCryptic\n(C) BankerA\n(D) Game-Troj", "output": "(A)"}
{"input": "A ___________ is a method in which a computer security mechanism is bypassed untraceable for accessing the computer or its information.\n(A) front-door\n(B) backdoor\n(C) clickjacking\n(D) key-logging", "output": "(B)"}
{"input": "The digest created by a hash function is normally called a\n(A) Modication detection code (MDC)\n(B) Modify authentication connection\n(C) Message authentication control\n(D) Message authentication cipher", "output": "(A)"}
{"input": "Encryption and decryption provide secrecy, or condentiality, but not\n(A) Authentication\n(B) Integrity\n(C) Privacy\n(D) All of the above", "output": "(B)"}
{"input": "MIT’s Kerberos KDC server has a maximum ticket lifetime of 24 hours (for most user principals). What ensures that an expired Kerberos ticket can no longer be used?\n(A) The Kerberos server (KDC) refuses to establish new connections between clients and servers for expired tickets.\n(B) When a client connects to a server, the server sets a 24-hour timer to terminate the connection, which ensures a client cannot remain connected past the ticket’s maximum lifetime.\n(C) When a client connects to a server, the server compares the ticket’s expiration time to the server’s current clock, and refuses to authenticate the user if the ticket expiration time is in the past.\n(D) When a client connects to a server, the server sends a query to the KDC to check if the ticket is still valid with respect to the KDC’s clock, and refuses to authenticate the user if the KDC reports that the ticket is expired.", "output": "(C)"}
{"input": "1. _________ framework made cracking of vulnerabilities easy like point and click.\n(A) .Net\n(B) Metasploit\n(C) Zeus\n(D) Ettercap", "output": "(B)"}
{"input": "Man in the middle attack can endanger the security of Diffie Hellman method if two parties are not\n(A) Joined\n(B) Authenticated\n(C) Submitted\n(D) Shared", "output": "(B)"}
{"input": "Can a stream cipher have perfect secrecy?\n(A) Yes, if the PRG is really “secure”\n(B) No, there are no ciphers with perfect secrecy\n(C) Yes, every cipher has perfect secrecy\n(D) No, since the key is shorter than the message", "output": "(D)"}
{"input": "Let HH be a Merkle-Damgard hash function is H:X^{\\leq L} \\to TH:X^≤L  →T. Construct a MAC from this HH as follows: \\ \\ S(k,m) = H(k \\| m)  S(k,m)=H(k∥m). This mac is insecure because:\n(A) Given H(k \\| m)H(k∥m) anyone can compute H(w \\| k \\| m \\| \\text{PB})H(w∥k∥m∥PB) for any ww\n(B) Given H(k \\| m)H(k∥m) anyone can compute H(k \\| m \\| w)H(k∥m∥w) for any ww\n(C) Given H(k \\| m)H(k∥m) anyone can compute H(k \\| m \\| \\text{PB} \\| w)H(k∥m∥PB∥w) for any ww\n(D) Anyone can compute H( k \\| m )H(k∥m) for any mm", "output": "(C)"}
{"input": "Why would a ping sweep be used?\n(A) To identify live systems\n(B) To locate live systems\n(C) To identify open ports\n(D) To locate firewalls", "output": "(A)"}
{"input": "Why is it that the compiler does not know the absolute address of a local variable?\n(A) Programs are not allowed to reference memory using absolute addresses\n(B) The size of the address depends on the architecture the program will run on\n(C) As a stack-allocated variable, it could have different addresses depending on when its containing function is called\n(D) Compiler writers are not very good at that sort of thing", "output": "(C)"}
{"input": "Assume that a TLS connection has been established successfully between a client and a server. Establishing the session included checking the server certificate and executing a DiffieHelmann exchange, but the client did not provide a client certificate. Further, assume that the client and server are honest, that the client and server don’t leak their keys, and that the cryptography is good. Which of the following attacks does TLS protect against?\n1. An attacker replaying bytes that a client sent earlier.\n2. An attacker impersonating the server.\n(A) True, True\n(B) False, False\n(C) True, False\n(D) False, True", "output": "(A)"}
{"input": "Which of the following is not a block cipher operating mode?\n(A) ECB\n(B) CFB\n(C) CBF\n(D) CBC", "output": "(C)"}
{"input": "Consider the paper Native Client: A Sandbox for Portable, Untrusted x86 Native Code by Yee et al. Ben Bitdiddle notes that NaCl uses Intel x86 segmentation to ensure that the sandboxed module does not read or write memory outside its own data area, and does not execute instructions outside its own code. Ben thinks that with these restrictions alone, executing the sandboxed module must be safe; that is, he thinks validation is not needed. Ben is wrong. Circle the types of x86 machine instructions that the validator always forbids in sandboxed code. Please ignore trampoline and springboard code.\n(A) all instructions that modify segment state\n(B) all loads or stores to addresses that are not 0 mod 32\n(C) all indirect loads or stores (via an address in a register or variable)\n(D) all indirect jumps (via an address in a register or variable)", "output": "(A)"}
{"input": "_______________ is the central node of 802.11 wireless operations.\n(A) WPA\n(B) Access Point\n(C) WAP\n(D) Access Port", "output": "(B)"}
